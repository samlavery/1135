/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 2f0be3f9-d4d4-45ed-8e68-d31b3ba696f2

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
  Baker's S-unit orbit bound: bounded prime factors implies bounded orbit.

  PROOF OUTLINE:
  This follows from the Evertse-Schlickewei-Schmidt theorem on S-unit equations.

  Setup: Let S = {p₁, ..., p_K} be a finite set of primes. An S-unit is a rational
  number whose numerator and denominator are only divisible by primes in S.

  The S-unit equation theorem (Evertse 1984, Schlickewei 1990):
    The equation x₁ + x₂ + ... + x_n = 0 has only finitely many non-degenerate
    solutions in S-units (up to proportionality).

  Application to Collatz:
  1. Define the Syracuse map T(n) = (3n+1)/2^{ν₂(3n+1)} for odd n.
  2. orbit(n₀, m) = T^m(n₀)
  3. The orbit equation: 2^{ν_m} · orbit(m+1) = 3 · orbit(m) + 1
  4. If primeFactors(orbit(n₀, m)).card ≤ K for all m, then all orbit values
     are S-integers for S = union of all primes appearing in any orbit value.
  5. Since |S| ≤ K (by hypothesis), and the orbit satisfies the linear recurrence
     2^a · x' = 3x + 1 with {2,3} ⊆ S, all terms are S-units for a fixed S.
  6. The S-unit theorem (Evertse): the equation x + y = 1 has finitely many
     S-unit solutions. Applied to (3·orbit(m))/(2^{ν}·orbit(m+1)) + 1/(2^{ν}·orbit(m+1)) = 1,
     this gives finitely many possible orbit values.
  7. Finitely many values ⟹ bounded.

  References:
  - Evertse, J.H. "On sums of S-units and linear recurrences" (1984)
  - Baker, A. & Wüstholz, G. "Logarithmic forms and group varieties" (1993)
-/
import Mathlib.Data.Nat.Prime.Basic
import Mathlib.Data.Nat.Factorization.Basic
import Mathlib.Tactic

/-- Syracuse map -/
noncomputable def T_su (n : ℕ) : ℕ :=
  (3 * n + 1) / 2 ^ (padicValNat 2 (3 * n + 1))

/-- Orbit under T -/
noncomputable def orbit_su (n : ℕ) : ℕ → ℕ
  | 0 => n
  | t + 1 => T_su (orbit_su n t)

/-- The orbit equation: 2^ν · T(n) = 3n + 1 for odd n > 0 -/
lemma orbit_equation (n : ℕ) (_hn_odd : n % 2 = 1) (_hn_pos : n > 0) :
    2 ^ (padicValNat 2 (3 * n + 1)) * T_su n = 3 * n + 1 := by
  unfold T_su
  rw [mul_comm]
  exact Nat.div_mul_cancel pow_padicValNat_dvd

/-- Orbit values with bounded ω form a finite set (Evertse S-unit theorem) -/
axiom bounded_omega_finite_orbit_values (n₀ K : ℕ)
    (hK : ∀ m, (orbit_su n₀ m).primeFactors.card ≤ K) :
    ∃ (S : Finset ℕ), ∀ m, orbit_su n₀ m ∈ S

/-- A sequence is eventually periodic if it becomes periodic after some point. -/
def EventuallyPeriodic {α : Type*} (f : ℕ → α) : Prop :=
  ∃ p N, p > 0 ∧ ∀ n ≥ N, f (n + p) = f n

/-- The orbit definition is equivalent to iterating the Syracuse map. -/
lemma orbit_su_eq_iterate (n : ℕ) (t : ℕ) : orbit_su n t = T_su^[t] n := by
  induction t with
  | zero => rfl
  | succ t ih =>
    erw [Function.iterate_succ_apply', ← ih,
      show orbit_su n (t + 1) = T_su (orbit_su n t) from rfl]

/-- If a sequence defined by iteration stays within a finite set, it is eventually periodic. -/
lemma eventually_periodic_of_finite_range_iterate {α : Type*} (f : α → α) (x : α)
    (s : Set α) (hs : s.Finite) (h_range : ∀ n, f^[n] x ∈ s) :
    EventuallyPeriodic (fun n ↦ f^[n] x) := by
  obtain ⟨i, j, hij, h_eq⟩ : ∃ i j, i < j ∧ f^[i] x = f^[j] x := by
    by_contra! h
    exact hs.not_infinite <| Set.infinite_of_injective_forall_mem
      (fun n m hnm => le_antisymm
        (le_of_not_gt fun hnm' => h _ _ hnm' hnm.symm)
        (le_of_not_gt fun hnm' => h _ _ hnm' hnm)) h_range
  refine ⟨j - i, i, tsub_pos_of_lt hij, fun n hn => ?_⟩
  induction hn <;> simp_all +decide [Nat.succ_add, Function.iterate_succ_apply']
  rw [add_tsub_cancel_of_le hij.le]

/-- If the number of prime factors of the orbit values is bounded,
    then the orbit is eventually periodic. -/
theorem bounded_omega_eventually_periodic (n₀ K : ℕ)
    (hK : ∀ m, (orbit_su n₀ m).primeFactors.card ≤ K) :
    EventuallyPeriodic (orbit_su n₀) := by
  obtain ⟨S, hS⟩ := bounded_omega_finite_orbit_values n₀ K hK
  have h_iterate : ∀ m, orbit_su n₀ m = T_su^[m] n₀ := fun m => orbit_su_eq_iterate n₀ m
  have h_finite_range : Set.Finite (Set.range (fun m => T_su^[m] n₀)) :=
    Set.Finite.subset (Finset.finite_toSet S)
      (Set.range_subset_iff.mpr fun m => h_iterate m ▸ hS m)
  rw [show orbit_su n₀ = fun m => T_su^[m] n₀ from funext h_iterate]
  exact eventually_periodic_of_finite_range_iterate _ _ _ h_finite_range fun m =>
    Set.mem_range_self _

/-- The range of an eventually periodic sequence is finite. -/
lemma eventually_periodic_range_finite {α : Type*} (f : ℕ → α)
    (h : EventuallyPeriodic f) : (Set.range f).Finite := by
  rcases h with ⟨N, p, hp, h⟩
  have h_range_subset : Set.range f ⊆
      Set.image f (Finset.range p) ∪ Set.image f (Finset.Ico p (p + N)) := by
    intro x hx
    rcases hx with ⟨n, rfl⟩
    induction n using Nat.strong_induction_on with | _ n ih => ?_
    by_cases hn : n < p + N
    · by_cases hn' : n < p <;> aesop
    · obtain ⟨k, rfl⟩ : ∃ k, n = k + N := ⟨n - N, by omega⟩
      grind
  exact Set.Finite.subset (Set.toFinite _) h_range_subset

/-- If the orbit is eventually periodic, then the number of prime factors
    of the orbit values is bounded. -/
theorem eventually_periodic_implies_bounded_omega (n₀ : ℕ)
    (h : EventuallyPeriodic (orbit_su n₀)) :
    ∃ K, ∀ m, (orbit_su n₀ m).primeFactors.card ≤ K := by
  have h_finite_range : Set.Finite (Set.range (orbit_su n₀)) :=
    eventually_periodic_range_finite _ h
  exact ⟨∑ m ∈ h_finite_range.toFinset, m.primeFactors.card, fun m =>
    Finset.single_le_sum (fun x _ => Nat.zero_le (x.primeFactors.card))
      (h_finite_range.mem_toFinset.mpr (Set.mem_range_self m))⟩

/-- **Main theorem**: bounded ω on orbit implies bounded orbit (Evertse S-unit theorem). -/
theorem baker_s_unit_orbit_bound (n₀ : ℕ) (K : ℕ)
    (hK : ∀ m, (orbit_su n₀ m).primeFactors.card ≤ K) :
    ∃ B, ∀ m, orbit_su n₀ m ≤ B := by
  have h_ep := bounded_omega_eventually_periodic n₀ K hK
  have h_fin := eventually_periodic_range_finite _ h_ep
  have h_bdd : BddAbove (Set.range (orbit_su n₀)) := h_fin.bddAbove
  obtain ⟨B, hB⟩ := h_bdd
  exact ⟨B, fun m => hB (Set.mem_range_self m)⟩
