/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b9580719-171c-40fd-b92d-1979c5165c28
-/

/-
We defined the Syracuse map and the associated pattern of 2-adic valuations. We proved the orbit formula and the congruence relation it implies. We formalized the key fact about the multiplicative order of 3 modulo 2^k. Finally, we proved the density bound for subcritical patterns, showing that the number of odd integers n ≤ N realizing a subcritical pattern σ of length m is at most N/2^m + 1, which satisfies the required bound with α = 1.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The Syracuse map on odd positive integers: T(n) = (3n+1)/2^ν where ν = v₂(3n+1).
-/
def Syracuse (n : ℕ) : ℕ :=
  (3 * n + 1) / 2 ^ (padicValNat 2 (3 * n + 1))

/-
Define the ν-pattern of n over m steps as σ = (ν₀, ν₁, ..., ν_{m-1}) where νᵢ = v₂(3·Tⁱ(n) + 1).
-/
def SyracusePattern (n m : ℕ) : List ℕ :=
  (List.range m).map (fun i => padicValNat 2 (3 * (Syracuse^[i] n) + 1))

/-
A pattern σ is subcritical if Σνᵢ < m · log₂(3), equivalently 2^{Σνᵢ} < 3^m.
n realizes pattern σ if n is odd and its Syracuse pattern matches σ.
-/
def IsSubcritical (σ : List ℕ) : Prop :=
  2 ^ σ.sum < 3 ^ σ.length

def RealizesPattern (n : ℕ) (σ : List ℕ) : Prop :=
  n % 2 = 1 ∧ SyracusePattern n σ.length = σ

/-
Key Fact: The multiplicative order of 3 modulo 2^k is ord_{2^k}(3) = 2^{k-2} for k ≥ 3.
-/
theorem orderOf_three_mod_two_pow (k : ℕ) (hk : 3 ≤ k) :
  orderOf (3 : ZMod (2^k)) = 2^(k-2) := by
    -- We'll use that $3^{2^{k-2}} \equiv 1 \pmod{2^k}$ and $3^{2^{k-3}} \not\equiv 1 \pmod{2^k}$.
    have h_order : 3 ^ (2 ^ (k - 2)) ≡ 1 [MOD 2 ^ k] ∧ ¬(3 ^ (2 ^ (k - 3)) ≡ 1 [MOD 2 ^ k]) := by
      constructor;
      · rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.pow_succ' ];
        -- We'll use induction to prove that $3^{2^k} \equiv 1 \pmod{2^{k+2}}$.
        have h_ind : ∀ k : ℕ, 1 ≤ k → 3 ^ 2 ^ k ≡ 1 [MOD 2 ^ (k + 2)] := by
          intro k hk; rw [ Nat.modEq_iff_dvd ] ; induction hk <;> simp_all +decide [ Nat.pow_succ, pow_mul ];
          rename_i k hk ih; convert mul_dvd_mul ih ( show 2 ∣ 1 + 3 ^ 2 ^ k from even_iff_two_dvd.mp ( by norm_num [ parity_simps ] ) ) using 1 ; ring;
        convert h_ind k hk using 1 ; ring;
      · -- We'll use that $3^{2^{k-3}} \equiv 2^{k-1} + 1 \pmod{2^k}$ for $k \geq 4$.
        have h_cong : ∀ k ≥ 4, 3 ^ (2 ^ (k - 3)) ≡ 2 ^ (k - 1) + 1 [MOD 2 ^ k] := by
          intro k hk_ge_4
          induction' hk_ge_4 with k hk ih;
          · decide;
          · rcases k with ( _ | _ | _ | k ) <;> simp_all +decide [ Nat.modEq_iff_dvd ];
            rcases ih with ⟨ m, hm ⟩ ; ring_nf at hm ⊢;
            rw [ pow_mul ];
            rw [ show ( 3 ^ 2 ^ k ) = ( 1 + ( 2 ^ k * 4 - m * 2 ^ k * 8 ) ) by linarith ] ; ring_nf;
            exact ⟨ m + m * 2 ^ k * 4 + ( - ( m ^ 2 * 2 ^ k * 4 ) - 2 ^ k ), by ring ⟩;
        by_cases hk4 : k ≥ 4;
        · have := h_cong k hk4;
          intro h; have := this.symm.trans h; rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.modEq_iff_dvd ] ;
          exact absurd this ( mod_cast Nat.not_dvd_of_pos_of_lt ( by positivity ) ( by ring_nf; norm_num ) );
        · interval_cases k ; trivial;
    refine' orderOf_eq_of_pow_and_pow_div_prime _ _ _;
    · positivity;
    · simpa [ ← ZMod.natCast_eq_natCast_iff ] using h_order.1;
    · intro p pp dp; have := Nat.Prime.dvd_of_dvd_pow pp dp; simp_all +decide [ Nat.prime_dvd_prime_iff_eq ] ;
      rcases k with ( _ | _ | _ | k ) <;> simp_all +decide [ pow_succ ];
      simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ]

/-
Define the wavesum W(σ) using the recurrence W_{k+1} = 3 W_k + 2^{S_k}.
-/
def SyracuseWavesum (σ : List ℕ) : ℕ :=
  (σ.foldl (fun (w, s) ν => (3 * w + 2 ^ s, s + ν)) (0, 0)).1

/-
T(n) * 2^ν = 3n + 1 where ν = v₂(3n+1).
-/
lemma Syracuse_step (n : ℕ) : Syracuse n * 2 ^ (padicValNat 2 (3 * n + 1)) = 3 * n + 1 := by
  exact Nat.div_mul_cancel <| Nat.ordProj_dvd _ _

/-
The orbit formula gives: Tᵐ(n) · 2^S = 3^m · n + W(σ), where W is the "wavesum" determined by σ.
-/
lemma SyracuseOrbitFormula (n m : ℕ) (σ : List ℕ) (hσ : σ = SyracusePattern n m) :
  (Syracuse^[m] n) * 2 ^ σ.sum = 3 ^ m * n + SyracuseWavesum σ := by
    subst hσ;
    induction' m with m ih generalizing n <;> simp_all +decide [ Function.iterate_succ_apply', pow_succ', mul_assoc ];
    · unfold SyracusePattern SyracuseWavesum; aesop;
    · -- Apply the Syracuse step to the m-th iterate of n.
      have h_syracuse_step : Syracuse (Syracuse^[m] n) * 2 ^ (padicValNat 2 (3 * (Syracuse^[m] n) + 1)) = 3 * (Syracuse^[m] n) + 1 := by
        exact?;
      -- Substitute the induction hypothesis into the equation.
      have h_subst : Syracuse (Syracuse^[m] n) * 2 ^ (List.sum (SyracusePattern n m) + padicValNat 2 (3 * (Syracuse^[m] n) + 1)) = 3 * (3 ^ m * n + SyracuseWavesum (SyracusePattern n m)) + 2 ^ (List.sum (SyracusePattern n m)) := by
        rw [ pow_add, ← ih ] ; nlinarith [ pow_pos ( zero_lt_two' ℕ ) ( List.sum ( SyracusePattern n m ) ) ] ;
      convert h_subst using 1;
      · unfold SyracusePattern; simp +decide [ List.range_succ ] ;
      · unfold SyracuseWavesum SyracusePattern; simp +decide [ List.range_succ ] ; ring;
        induction ( List.range m ) using List.reverseRecOn <;> aesop

/-
The Syracuse map preserves oddness.
-/
lemma Syracuse_preserves_odd (n : ℕ) (h : n % 2 = 1) : Syracuse n % 2 = 1 := by
  -- By definition of Syracuse, we know that Syracuse n = (3 * n + 1) / 2 ^ (padicValNat 2 (3 * n + 1)).
  unfold Syracuse;
  -- By definition of $v₂$, we know that $2^{v₂(3n+1)}$ divides $3n+1$ but $2^{v₂(3n+1)+1}$ does not.
  have h_div : 2 ^ (padicValNat 2 (3 * n + 1)) ∣ 3 * n + 1 ∧ ¬2 ^ (padicValNat 2 (3 * n + 1) + 1) ∣ 3 * n + 1 := by
    exact ⟨ Nat.ordProj_dvd _ _, Nat.pow_succ_factorization_not_dvd ( by norm_num ) ( by norm_num ) ⟩;
  exact Nat.mod_two_ne_zero.mp fun contra => h_div.2 <| by convert Nat.mul_dvd_mul_left ( 2 ^ padicValNat 2 ( 3 * n + 1 ) ) ( Nat.dvd_of_mod_eq_zero contra ) using 1; linarith [ Nat.div_mul_cancel h_div.1 ] ;

/-
All valuations in the pattern are at least 1.
-/
lemma SyracusePattern_ge_one (n m : ℕ) (h : n % 2 = 1) :
  ∀ ν ∈ SyracusePattern n m, 1 ≤ ν := by
    -- By definition of Syracuse, we know that T(n) = (3n + 1) / 2^ν where ν = v₂(3n + 1). Since n is odd, 3n + 1 is even, so ν is at least 1.
    have hν_pos : ∀ n, n % 2 = 1 → 1 ≤ padicValNat 2 (3 * n + 1) := by
      exact fun n hn => Nat.pos_of_ne_zero ( by rw [ Ne.eq_def, padicValNat.eq_zero_iff ] ; norm_num ; omega );
    -- Applying the hypothesis `hν_pos` to each element in the list `SyracusePattern n m`.
    have hν_pos_list : ∀ i < m, 1 ≤ padicValNat 2 (3 * (Syracuse^[i] n) + 1) := by
      intro i hi
      have h_odd_i : (Syracuse^[i] n) % 2 = 1 := by
        exact Nat.recOn i h fun i hi => by rw [ Function.iterate_succ_apply' ] ; exact Syracuse_preserves_odd _ hi;
      exact hν_pos (Syracuse^[i] n) h_odd_i;
    unfold SyracusePattern; aesop

/-
For n to realize pattern σ, we need: 3^m * n + W(σ) ≡ 0 (mod 2^S).
-/
def SyracuseSum (σ : List ℕ) : ℕ := σ.sum

lemma Syracuse_congruence (n m : ℕ) (σ : List ℕ) (hσ : σ = SyracusePattern n m) :
  3 ^ m * n + SyracuseWavesum σ ≡ 0 [MOD 2 ^ (SyracuseSum σ)] := by
    -- Apply the orbit formula to get the congruence relation.
    have h_orbit : (Syracuse^[m] n) * 2 ^ σ.sum = 3 ^ m * n + SyracuseWavesum σ := by
      exact?;
    exact Nat.modEq_zero_iff_dvd.mpr ( h_orbit ▸ dvd_mul_left _ _ )

/-
The number of n ≤ N satisfying n ≡ a (mod m) is at most N/m + 1.
-/
lemma count_modEq_card (N m a : ℕ) (hm : m > 0) :
  ((Finset.range (N + 1)).filter (fun x => x ≡ a [MOD m])).card ≤ (N / m) + 1 := by
    have h_complete_residue : {x ∈ Finset.range (N + 1) | x ≡ a [MOD m]} ⊆ Finset.image (fun k => a % m + k * m) (Finset.range (N / m + 1)) := by
      intro x hx;
      exact Finset.mem_image.mpr ⟨ x / m, Finset.mem_range.mpr ( Nat.lt_succ_of_le ( Nat.div_le_div_right ( by linarith [ Finset.mem_range.mp ( Finset.mem_filter.mp hx |>.1 ) ] ) ) ), by linarith [ Nat.mod_add_div x m, Nat.mod_eq_of_lt hm, Nat.mod_eq_of_lt hm, show x % m = a % m from Finset.mem_filter.mp hx |>.2 ] ⟩;
    exact le_trans ( Finset.card_le_card h_complete_residue ) ( Finset.card_image_le.trans ( by norm_num ) )

/-
3^m and 2^k are coprime.
-/
lemma coprime_three_pow_two_pow (m k : ℕ) : Nat.Coprime (3 ^ m) (2 ^ k) := by
  apply_rules [ Nat.Coprime.pow ]

/-
For a fixed subcritical pattern σ, the number of n ≤ N realizing σ is at most N/2^S + 1.
-/
theorem SubcriticalDensityBound_FixedPattern (m N : ℕ) (σ : List ℕ)
  (h_len : σ.length = m) (h_sub : IsSubcritical σ) :
  ((Finset.range (N + 1)).filter (fun n => RealizesPattern n σ)).card ≤ (N / 2 ^ σ.sum) + 1 := by
    -- By definition of realizations, the number of n ≤ N realizing σ is at most the number of n ≤ N satisfying 3^m * n + W(σ) ≡ 0 (mod 2^S).
    have h_count : ((Finset.range (N + 1)).filter (fun n => RealizesPattern n σ)).card ≤ ((Finset.range (N + 1)).filter (fun n => 3 ^ m * n + SyracuseWavesum σ ≡ 0 [MOD 2 ^ (σ.sum)])).card := by
      apply Finset.card_le_card;
      intro n hn;
      simp +zetaDelta at *;
      exact ⟨ hn.1, by simpa [ ← h_len ] using Syracuse_congruence n m σ ( by cases hn.2; aesop ) ⟩;
    refine le_trans h_count ?_;
    -- Apply the lemma count_modEq_card with a = -W(σ) * (3^m)^{-1} mod 2^S.
    have h_cong : ((Finset.range (N + 1)).filter (fun n => 3 ^ m * n + SyracuseWavesum σ ≡ 0 [MOD 2 ^ (σ.sum)])).card ≤ ((Finset.range (N + 1)).filter (fun n => n ≡ -SyracuseWavesum σ * Nat.gcdA (3 ^ m) (2 ^ (σ.sum)) [ZMOD 2 ^ (σ.sum)])).card := by
      have h_cong : ∀ n : ℕ, 3 ^ m * n + SyracuseWavesum σ ≡ 0 [MOD 2 ^ (σ.sum)] → n ≡ -SyracuseWavesum σ * Nat.gcdA (3 ^ m) (2 ^ (σ.sum)) [ZMOD 2 ^ (σ.sum)] := by
        intro n hn
        have h_cong : 3 ^ m * n ≡ -SyracuseWavesum σ [ZMOD 2 ^ (σ.sum)] := by
          exact Int.ModEq.symm <| Int.modEq_of_dvd <| by simpa [ ← Int.natCast_dvd_natCast ] using Nat.dvd_of_mod_eq_zero hn;
        have h_cong : 3 ^ m * Nat.gcdA (3 ^ m) (2 ^ (σ.sum)) ≡ 1 [ZMOD 2 ^ (σ.sum)] := by
          have := Nat.gcd_eq_gcd_ab ( 3 ^ m ) ( 2 ^ σ.sum );
          rw [ Int.modEq_iff_dvd ];
          norm_num [ Nat.Coprime, Nat.Coprime.pow ] at *;
          exact ⟨ Nat.gcdB ( 3 ^ m ) ( 2 ^ σ.sum ), by linarith ⟩;
        have := h_cong.mul_left n; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff, mul_assoc, mul_comm, mul_left_comm ] ;
        exact this.symm.trans ( by convert ‹ ( n : ℤ ) * 3 ^ m ≡ - ( SyracuseWavesum σ : ℤ ) [ZMOD 2 ^ σ.sum ] ›.mul_right ( Nat.gcdA ( 3 ^ m ) ( 2 ^ σ.sum ) ) using 1 <;> ring );
      have h_cong : Finset.image (fun n : ℕ => (n : ℤ)) (Finset.filter (fun n => 3 ^ m * n + SyracuseWavesum σ ≡ 0 [MOD 2 ^ (σ.sum)]) (Finset.range (N + 1))) ⊆ Finset.filter (fun n : ℤ => n ≡ -SyracuseWavesum σ * Nat.gcdA (3 ^ m) (2 ^ (σ.sum)) [ZMOD 2 ^ (σ.sum)]) (Finset.image (fun n : ℕ => (n : ℤ)) (Finset.range (N + 1))) := by
        intro x hx
        aesop;
      convert Finset.card_le_card h_cong using 1;
      · rw [ Finset.card_image_of_injective _ Nat.cast_injective ];
      · norm_num [ Finset.filter_image ];
        convert rfl;
    refine le_trans h_cong ?_;
    convert count_modEq_card N ( 2 ^ σ.sum ) ( Int.toNat ( - ( SyracuseWavesum σ : ℤ ) * Nat.gcdA ( 3 ^ m ) ( 2 ^ σ.sum ) % ( 2 ^ σ.sum ) ) ) ( by positivity ) using 1;
    refine' Finset.card_bij ( fun x hx => Int.toNat x ) _ _ _ <;> norm_num;
    · simp +decide [ ← Int.natCast_modEq_iff ];
      exact fun a ha₁ ha₂ => ⟨ mod_cast ha₁, by rw [ max_eq_left ( Int.emod_nonneg _ ( by positivity ) ) ] ; simpa [ Int.ModEq ] using ha₂ ⟩;
    · intro b hb hb'; use b; simp_all +decide [ ← Int.natCast_modEq_iff ] ;
      exact hb'.trans ( by rw [ max_eq_left ( Int.emod_nonneg _ ( by positivity ) ) ] ; simp +decide [ Int.ModEq ] )

/-
The sum of valuations is at least the length.
-/
lemma SyracuseSum_ge_length (n m : ℕ) (h : n % 2 = 1) :
  (SyracusePattern n m).sum ≥ (SyracusePattern n m).length := by
    simpa using List.sum_le_sum fun x hx => Nat.one_le_of_lt <| SyracusePattern_ge_one n m h x hx

/-
For any subcritical ν-pattern σ of length m, the set of odd n ≤ N realizing σ has cardinality at most N / 2^{αm} + 1.
We choose α = 1.
From `SubcriticalDensityBound_FixedPattern`, the cardinality is at most N / 2^S + 1.
From `SyracuseSum_ge_length`, S ≥ m.
Therefore, 2^S ≥ 2^m = 2^{αm}.
Thus, N / 2^S ≤ N / 2^{αm}.
The result follows.
-/
noncomputable def alpha : ℝ := 1

theorem SubcriticalDensityBound (m N : ℕ) (σ : List ℕ)
  (h_len : σ.length = m) (h_sub : IsSubcritical σ) :
  ((Finset.range (N + 1)).filter (fun n => RealizesPattern n σ)).card ≤ (N / (2 : ℝ) ^ (alpha * m)) + 1 := by
    unfold alpha;
    have := SubcriticalDensityBound_FixedPattern m N σ h_len h_sub;
    contrapose! this;
    refine' Nat.lt_of_not_ge fun h => this.not_le _;
    refine le_trans ( Nat.cast_le.mpr h ) ?_;
    norm_num [ h_len ];
    rw [ le_div_iff₀ ] <;> norm_cast <;> norm_num;
    refine' Nat.le_trans ( Nat.mul_le_mul_left _ ( pow_le_pow_right₀ ( by decide ) ( show m ≤ σ.sum from _ ) ) ) _;
    · have h_sum_ge_length : ∀ n : ℕ, n % 2 = 1 → (SyracusePattern n σ.length).sum ≥ (SyracusePattern n σ.length).length := by
        exact?;
      have h_exists_odd : ∃ n : ℕ, n % 2 = 1 ∧ SyracusePattern n σ.length = σ := by
        obtain ⟨ n, hn ⟩ := Finset.card_pos.mp ( Nat.cast_pos.mp ( lt_of_le_of_lt ( by positivity ) this ) ) ; use n; aesop;
      grind;
    · exact Nat.div_mul_le_self _ _